import copy
import numpy as np

import torch
import torch.nn as nn
import torch.nn.functional as F

from adversarialbox.utils import to_var

# --- White-box attacks ---

class PGD20(object):
    def __init__(self, model, epsilon, k, a,):
        self.model = model
        self.epsilon = epsilon
        self.a = a
        self.k = k
        self.loss_fn = nn.KLDivLoss(reduction='batchmean')

    def perturb(self, X_nat,Y):
        '''
        X_nat是干净样本,X_adv是对抗样本,
        size是图像的大小
        '''
        # 初始化扰动
        I = np.eye(32, 32)  # 生成单位矩阵 I
        mean = 0  # 均值为 0
        std_dev = 1  # 标准差为 1
        noise = np.random.normal(mean, std_dev, X_nat.shape)  # 生成 N(0, I) 的随机数
        X_adv=X_nat+0.001*noise.astype('float32')
        #复制
        X = np.copy(X_nat)
        X_A=np.copy(X_adv)
        # print(X_A-X)
        # print((X_A-X).shape)
        #对每一个图像进行扰动
        for i in range(self.k):
            # print("PGD20 attack step:", i)
            X_var_nat = to_var(torch.from_numpy(X), requires_grad=True)
            X_var_adv = to_var(torch.from_numpy(X_A), requires_grad=True)

            f_X_nat = F.log_softmax(self.model(X_var_nat), dim=1)
            f_X_adv = F.softmax(self.model(X_var_adv), dim=1)

            loss = self.loss_fn(f_X_nat, f_X_adv)

            loss.backward()
            # print(loss)
            grad = X_var_adv.grad.data.cpu().numpy()
            # print((X_A-X)[0][0])
            X_A += self.a* np.sign(grad)
            # print("------------------X_A---------------------")
            # print((X_A)[0][0])
            # print(self.epsilon)
            # print("------------------X_nat - self.epsilon----------------------")
            # print((X_nat - self.epsilon)[0][0])
            # print("------------------X_nat + self.epsilon----------------------")
            # print((X_nat + self.epsilon)[0][0])

            X_A = np.clip(X_A, X_nat - self.epsilon, X_nat + self.epsilon)
            
            # print((X_A-X)[0][0])
            X_A = np.clip(X_A, 0, 1) # ensure valid pixel range
        # print((X_A-X)[0][0])
        return X_A

