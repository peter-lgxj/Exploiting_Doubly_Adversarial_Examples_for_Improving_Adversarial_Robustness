import torch
import torch.nn as nn
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from torch.autograd import Variable
import torch.nn.functional as F

from adversarialbox.attacks import PGD20
from adversarialbox.train import adv_train
from adversarialbox.utils import to_var, pred_batch, test
from adversarialbox.training_loss import DAR

from models import ResNet18,ResBlock
from tqdm import tqdm


# Hyper-parameters
param = {
    'batch_size': 500,
    'test_batch_size': 100,
    'num_epochs': 120,
    'delay': 0,
    'learning_rate': 1e-3,
    'weight_decay': 4e-3,
    'epsilon': 4/255,
    'b':6,
    'y':100
}


# Data loaders
train_dataset = datasets.CIFAR10(root='./data/',train=True, download=True, 
    transform=transforms.ToTensor())
loader_train = torch.utils.data.DataLoader(train_dataset, 
    batch_size=param['batch_size'], shuffle=True)

test_dataset = datasets.CIFAR10(root='./data/', train=False, download=True, 
    transform=transforms.ToTensor())
loader_test = torch.utils.data.DataLoader(test_dataset, 
    batch_size=param['test_batch_size'], shuffle=True)


# Setup the model
net = ResNet18(ResBlock)
net.load_state_dict(torch.load('./models/trained_resnet18.pkl'))

if torch.cuda.is_available():
    print('CUDA ensabled.')
    net.cuda()

# net.train()

# Adversarial training setup
adversary_1 = PGD20(net,param['epsilon'],20,2/225)
adversary_2 = PGD20(net,param['epsilon'],20,2/225)

# Train the model
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.SGD(net.parameters(), lr=param['learning_rate'],weight_decay=param['weight_decay'], momentum=0.9)
criterion_adv = DAR(net,param['y'],param['b'])

for epoch in range(param['num_epochs']):

    print('Starting epoch %d / %d' % (epoch + 1, param['num_epochs']))
    for t,(x, y) in tqdm(enumerate(loader_train), total=len(loader_train)):
        net.train()
        x_var, y_var = to_var(x), to_var(y.long())
        loss = criterion(net(x_var), y_var)
        
        # print(t)
        # adversarial training
        if epoch+1 > param['delay']:
            y_pred = pred_batch(x, net)
            #第一次扰动
            x_adv = adv_train(x, y, net, criterion, adversary_1)
            # print(x_adv.shape)
            x_adv_var = to_var(x_adv,requires_grad=True)
            # print(x_adv_var.shape)
            # print("扰动一次成功")
            #第二次扰动
            x_adv_double = adv_train(x_adv,y,  net, criterion, adversary_2)
            x_adv_var_double = to_var(x_adv_double,requires_grad=True)
            # print("扰动两次成功")
            loss_adv = criterion_adv.DAR_loss(y_var,x_var,x_adv_var,x_adv_var_double)
            # print(loss_adv)
            loss =loss_adv

        if (t + 1) % 100 == 0:
            print('Epoch [%d/%d], Iter [%d/%d] Loss: %.4f'
                 % (epoch + 1, param['num_epochs'], t + 1, len(loader_train), loss.item()))
        # print('Epoch [%d/%d],Loss: %.4f'% (epoch + 1, param['num_epochs'],  loss.item()))

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
    
print("clear sample test:")
test(net, loader_test)

# for t,(x, y) in enumerate(loader_test):
#     x_var, y_var = to_var(x), to_var(y.long())
#     x_adv = adv_train(x,  net, criterion, adversary_1)
#     x_adv_var = to_var(x_adv,requires_grad=True)
#     x_adv_double = adv_train(x_adv,  net, criterion, adversary_2)
#     x_adv_var_double = to_var(x_adv_double,requires_grad=True)
    
    
# print("adversarail sample test:")
# test(net, loader_test)

torch.save(net.state_dict(), 'models/adv_trained_resnet18.pkl')
